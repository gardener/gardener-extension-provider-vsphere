package main

import (
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strconv"
	"time"

	gardenerutils "github.com/gardener/gardener/pkg/utils"
	"github.com/go-logr/logr"
	goipam "github.com/metal-stack/go-ipam"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"

	"github.com/gardener/gardener-extension-provider-vsphere/test/gcve-setup/common"
)

var (
	phase             = flag.String("phase", "", "Phase of this plugin, either [setup,shutdown]")
	serviceAccount    = flag.String("service-account", getEnv("GOOGLE_APPLICATION_CREDENTIALS", ""), "Filename of file containing SA key")
	location          = flag.String("location", getEnv("LOCATION", ""), "GCP location such as us-east4a")
	globalCidr        = flag.String("cidr", getEnv("MANAGEMENT_CIDR", ""), "CIDR for all management blocks")
	mgmtCidrBlockSize = flag.String("cidr-block-size", getEnv("MANAGEMENT_CIDR_SIZE", "23"), "block size for all management blocks")
	cloudId           = flag.String("cloud-id", getEnv("CLOUD_ID", ""), "cloud ID")
	credFile          = flag.String("cred-file", "", "Credential file location")
	allowScavenging   = flag.Bool("allow-scavenging", false, "Allow scavenging of private clouds in deletion")
	logger            logr.Logger
	svcAcctKey        map[string]string
)

func main() {
	opts := zap.Options{}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	log.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
	logger = log.Log.WithName("gcve-setup")

	var err error
	if err = validate(); err != nil {
		logger.Error(err, "error validating input flags")
		os.Exit(1)
	}

	startTime := time.Now()
	logger.Info("Starting at:", "time", startTime.String())
	serviceAccountBytes, err := os.ReadFile(*serviceAccount)
	if err != nil {
		logger.Error(err, "Could not read service account key")
		os.Exit(1)
	}
	err = json.Unmarshal(serviceAccountBytes, &svcAcctKey)
	if err != nil {
		logger.Error(err, "Could not unmarshal application credential JSON")
		os.Exit(1)
	}

	client := common.GetClient(svcAcctKey)

	if *phase == "setup" {
		var address *string
		if *allowScavenging {
			address, err = scavengeGCVE(client)
		}
		if err == nil && address == nil {
			address, err = setupGCVE(client)
		}
		if err != nil {
			logger.Error(err, "error in setup processing")
			os.Exit(1)
		}
		err = outputCreds(client, *address)
		if err != nil {
			logger.Error(err, "error in setup processing")
			os.Exit(1)
		}
	} else if *phase == "shutdown" {
		err = shutdownGCVE(client)
		if err != nil {
			logger.Error(err, "error in shutdown processing")
			os.Exit(1)
		}
	}

	logger.Info("Finishing at", "time", time.Now().String(), "duration", time.Since(startTime).String())
}

func validate() error {
	if serviceAccount == nil || *serviceAccount == "" {
		return errors.Errorf("--service-account flag must be set")
	}
	if len(*phase) == 0 || (*phase != "setup" && *phase != "shutdown" && *phase != "dummy") {
		return errors.Errorf("--phase flag is `%s' and must be ['setup', 'shutdown', 'dummy']", *phase)
	}
	return nil
}

// try to find a private cloud in deletion
func scavengeGCVE(client *http.Client) (*string, error) {
	var cache []common.PrivateCloud
	clouds, err := getPrivateClouds(client)
	if err != nil {
		return nil, err
	}
	for _, cloud := range clouds.PrivateClouds {
		if cloud.State == common.DELETED && cloud.ExpireTime.After(time.Now()) {
			cache = append(cache, cloud)
		}
	}
	if len(cache) == 0 {
		return nil, nil
	}

	sort.Slice(cache, func(i, j int) bool {
		return cache[i].DeleteTime.Before(*cache[j].DeleteTime)
	})

	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/%s:undelete", cache[0].Name)
	resp, err := client.Post(url, "application/json", nil)
	if err != nil {
		return nil, fmt.Errorf("transport error undeleting private cloud: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response undeleting private cloud: %d, %s", resp.StatusCode, body)
	}

	return &cache[0].Name, nil
}

func setupGCVE(client *http.Client) (*string, error) {
	logger.Info("setupGCVE()")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	ipam, err := setupIpam(ctx, client)
	if err != nil {
		logger.Error(err, "error in ipam setup")
		os.Exit(1)
	}

	prefixSize, err := strconv.ParseInt(*mgmtCidrBlockSize, 10, 8)
	if err != nil {
		logger.Error(err, "error parsing cidr-block-size")
		os.Exit(1)
	}

	prefix, err := ipam.AcquireChildPrefix(ctx, *globalCidr, uint8(prefixSize))
	if err != nil {
		logger.Error(err, "error in retrieving CIDR")
		os.Exit(1)
	}

	if *cloudId == "" {
		id, err := gardenerutils.GenerateRandomStringFromCharset(5, "abcdefghijklmnopqrstuvwxyz")
		if err != nil {
			return nil, fmt.Errorf("could not generate name: %w", err)
		}
		cloudId = &id
	}

	privateCloudAddr := fmt.Sprintf("%s/privateClouds/%s", getProjectAddress(), *cloudId)
	pc, err := getPrivateCloud(client, privateCloudAddr)
	if err != nil {
		return nil, err
	}

	var operation *common.Operation
	if pc == nil {
		// create a new PC
		operation, err = createNewPC(client, prefix.String())
	} else {
		// we have an existing PC
		operation, err = lookupExistingPC(client)
	}
	if err != nil {
		return nil, err
	}

	if operation != nil {
		req, err := http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+operation.Name, nil)
		if err != nil {
			return nil, fmt.Errorf("failure to create request: %w", err)
		}

		err = common.Poll(client, req, 3*time.Hour, func(p *common.Operation) error {
			if p.Done && p.Response["state"] == common.ACTIVE {
				return nil
			} else {
				return common.Wait
			}
		})

		if err == nil {
			return &privateCloudAddr, nil
		} else {
			return nil, err
		}
	}

	return nil, err
}

func shutdownGCVE(client *http.Client) error {
	logger.Info("shutdownGCVE()")

	privateCloudAddr := fmt.Sprintf("%s/privateClouds/%s", getProjectAddress(), *cloudId)
	pc, err := getPrivateCloud(client, privateCloudAddr)
	if err != nil {
		return err
	}

	if pc == nil {
		return fmt.Errorf("Private cloud deleted")
	}

	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/%s?force=true&delayHours=4", privateCloudAddr)
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("transport error deleting from /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("unexpected response posting to /privateClouds: %d, %s", resp.StatusCode, body)
	}

	_, err = http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+privateCloudAddr, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	return nil
}

func createNewPC(client *http.Client, cidr string) (*common.Operation, error) {
	pc := &common.PrivateCloud{
		ManagementCluster: common.ManagementCluster{
			NodeCount:  3,
			ClusterId:  *cloudId,
			NodeTypeId: "standard-72",
		},
		NetworkConfig: common.NetworkConfig{
			ManagementCidr:      cidr,
			VmwareEngineNetwork: fmt.Sprintf("projects/%s/locations/global/vmwareEngineNetworks/default", svcAcctKey["project_id"]),
		},
	}

	b, err := json.Marshal(pc)
	if err != nil {
		return nil, fmt.Errorf("could not marshall PrivateCloud: %w", err)
	}

	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/%s/privateClouds?privateCloudId=%s", getProjectAddress(), *cloudId)
	resp, err := client.Post(url, "application/json", bytes.NewReader(b))
	if err != nil {
		return nil, fmt.Errorf("transport error posting to /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to /privateClouds: %d, %s", resp.StatusCode, body)
	}
	return parseOperation(resp)
}

func lookupExistingPC(client *http.Client) (*common.Operation, error) {
	req, err := http.NewRequest("GET", fmt.Sprintf("https://vmwareengine.googleapis.com/v1/%s/operations", getProjectAddress()), nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to /operations: %d, %s", resp.StatusCode, body)
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}
	response := &common.List[common.Operation]{}
	err = json.Unmarshal(responseBytes, &response)
	if err != nil {
		return nil, fmt.Errorf("could not parse response body: %w", err)
	}
	privateCloudAddr := fmt.Sprintf("%s/privateClouds/%s", getProjectAddress(), *cloudId)
	for _, op := range response.Items {
		if op.Metadata["target"] == privateCloudAddr && !op.Done {
			return &op, nil
		}
	}
	return nil, nil
}

func parseOperation(resp *http.Response) (*common.Operation, error) {
	// recover the returned operation
	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}
	result := &common.Operation{}
	err = json.Unmarshal(responseBytes, &result)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal from response body: %w", err)
	}
	return result, err
}

func outputCreds(client *http.Client, privateCloudAddr string) error {
	f, err := os.Create(*credFile)
	if err != nil {
		return fmt.Errorf("error creating credentials file: %w", err)
	}
	defer f.Close()

	privateCloud, err := getPrivateCloud(client, privateCloudAddr)
	if err != nil {
		return err
	}

	nsxCredentials, err := getCredentials(client, privateCloudAddr, "NsxCredentials")
	if err != nil {
		return err
	}
	vcenterCredentials, err := getCredentials(client, privateCloudAddr, "VcenterCredentials")
	if err != nil {
		return err
	}

	results := common.RunResults{
		PrivateCloud:       *privateCloud,
		NsxCredentials:     *nsxCredentials,
		VcenterCredentials: *vcenterCredentials,
	}

	b, err := yaml.Marshal(results)
	if err != nil {
		return fmt.Errorf("failure to marshal results: %w", err)
	}
	_, err = f.Write(b)
	if err != nil {
		return fmt.Errorf("failure to write output: %w", err)
	}
	return nil
}

func getCredentials(client *http.Client, privateCloudAddr string, credType string) (*common.Credentials, error) {
	url := "https://vmwareengine.googleapis.com/v1/" + privateCloudAddr + ":show" + credType
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode >= 300 {
		return nil, fmt.Errorf("unexpected response posting to %s: %d, %s", url, resp.StatusCode, body)
	}
	credential := &common.Credentials{}
	err = json.Unmarshal(body, credential)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	return credential, nil
}

func getPrivateClouds(client *http.Client) (*common.ListPrivateClouds, error) {
	url := "https://vmwareengine.googleapis.com/v1/" + getProjectAddress() + "/privateClouds"

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to %s: %d, %s", url, resp.StatusCode, body)
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}
	response := &common.ListPrivateClouds{}
	err = json.Unmarshal(responseBytes, &response)

	return response, err
}

func getPrivateCloud(client *http.Client, address string) (*common.PrivateCloud, error) {
	url := "https://vmwareengine.googleapis.com/v1/" + address
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == 404 {
		return nil, nil
	}
	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to %s: %d, %s", url, resp.StatusCode, body)
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}

	response := &common.PrivateCloud{}
	err = json.Unmarshal(responseBytes, &response)

	return response, err
}

func getProjectAddress() string {
	return fmt.Sprintf("projects/%s/locations/%s", svcAcctKey["project_id"], *location)
}

// Create an IPAM from all the existing address blocks
func setupIpam(ctx context.Context, client *http.Client) (goipam.Ipamer, error) {
	ipam := goipam.New()

	clouds, err := getPrivateClouds(client)
	if err != nil {
		return nil, err
	}

	_, err = ipam.NewPrefix(ctx, *globalCidr)
	if err != nil {
		return nil, err
	}
	for _, cloud := range clouds.PrivateClouds {
		_, err = ipam.AcquireSpecificChildPrefix(ctx, *globalCidr, cloud.NetworkConfig.ManagementCidr)
		if err != nil {
			return nil, err
		}
	}

	return ipam, nil
}

func getEnv(key string, defaultVal string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}

	return defaultVal
}
